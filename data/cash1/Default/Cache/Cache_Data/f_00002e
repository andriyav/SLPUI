function buildFunction(values){
    let foo_all = values.func_name + "(";
    Object.keys(values).forEach(key=> {
      if (key!== "func_name")
        foo_all += `${key}=${values[key]}${$ARG_ITEM_SEPARATOR}`
    })
    return foo_all.slice(0, foo_all.endsWith("(")? foo_all.length: foo_all.length-1) + ")";
}

function buildSpanFunction(spansContents, index){
    let funcParams = [];
    Object.keys(spansContents.func_data[index].params).forEach(param_name=> {
        funcParams.push(`${param_name}=${spansContents.func_data[index].params[param_name]}`)
    });
    return `${spansContents.func[index]}(${funcParams.join($ARG_ITEM_SEPARATOR)})`
}

function convertFuncParams(values, morph_info) {
    let foo = meta_map[morph_info[1]].filter(v  => v.name === values.func_name)[0];
    delete values.func_name;
    if (foo){
        foo.params.forEach(param=> {
            let types = param.types;
            if (types.includes("list") || types.includes("dict") || types.includes("bool"))
                values[param.name] = JSON.parse(values[param.name])
        })
    }
    return values;
}

function update_filled_values(kw_field="",values="", position="") {
    let foo_obj = getInfo(kw_field);
    let field = foo_obj[2];
    let morph = foo_obj[1];
    let current_map = $activeMap[foo_obj[0]];

    switch (position) {
        case "add":
            if (!current_map[field])
                current_map[field] = Object.fromEntries(morphs.map(k => [k, null]));
            if (!current_map[field][morph]){ current_map[field][morph] = {'func':[], 'func_data':[]} }
            current_map[field][morph]['func'].push(values.func_name);
            current_map[field][morph]['func_data'].push({
                "params": Object.assign({}, convertFuncParams(values, getInfo(kw_field)))
            });
            break

        case "edit":
            let funcIndex = current_map[field][morph]['func'].indexOf(values.func_name);
            current_map[field][morph]['func_data'][funcIndex] = {
                "params": Object.assign({}, convertFuncParams(values, getInfo(kw_field)))
            };
            break

        case "delete":
            current_map[field][morph]['func'].splice(values.func_index, 1);
            current_map[field][morph]['func_data'].splice(values.func_index, 1);
            if (!current_map[field][morph]['func'].length) {
                current_map[field][morph] = null;
            }
            break
    };

}

function isValidaValues(values) {
    let foo = null;
    let vv = Object.keys(values);
    let errors = [];

    for (let morph of morphs){
        for(let foo_obj of meta_map[morph]){
            if (values.func_name === foo_obj.name){
                foo = foo_obj;
                let isAllParams = true;
                foo_obj.params.forEach(p => {
                    if (p.default === undefined && !vv.includes(p.name)){ isAllParams = false}
                });
                if (!isAllParams)
                    errors.push({uri: "Function:", message: "Not all params are provided."});
            }
        }
    }

    for (let param_obj of foo.params){
        try {
            // if no value and default is present than skip checks
            if (!values[param_obj.name] && param_obj.default !== undefined)
                continue;
            let arg_types = param_obj.types;
            if (arg_types.includes("list") || arg_types.includes("dict")){
                let rez = JSON.parse(values[param_obj.name]);
                if (typeof(rez) != 'object')
                    throw new TypeError(`${param_obj.name} must be ${param_obj.types.join(" or ")}`);
                if (arg_types.includes("list") && !arg_types.includes("dict") && !Array.isArray(rez))
                  throw new TypeError(`${param_obj.name} must be list`);
                if  (arg_types.includes("dict") && !arg_types.includes("list") && Array.isArray(rez))
                  throw new TypeError(`${param_obj.name} must be dict`);
          }
            if (arg_types.includes("bool") && arg_types.length === 1
                && !["true", "false"].includes(values[param_obj.name]))
                throw new TypeError(`${param_obj.name} must be ${param_obj.types.join(" or ")}`);
        } catch (e) {
          errors.push({uri: param_obj.name, message: e.message});
        }
    }

    $(".is-invalid").removeClass("is-invalid");
    $(".invalid-feedback").remove();
    for (let e of errors)
        $(`.form-control[aria-label="${e.uri}"`).addClass("is-invalid")
        .after(`<div class='invalid-feedback'>${e.message}</div>`);
    return errors.length;
}

function buildSpanIndex(elementIdPrefix, elementIndex){
    return `${elementIdPrefix}__${elementIndex}`;
}

$addForm={
    "schema":{}, "form":[], value: {},
    onSubmit: function (errors, values) {
        if (errors) {
             flash("danger", errors[0].message);
        } else {
        console.log("In Click");
        if ( isValidaValues(values)){
            return
        }
        // remove rule name from values do not include it to function card
        delete values.rule_body;

        let id_element = $clicked.name;

        let element_span = $(document.getElementsByName(id_element));
        let parent = element_span.parent();
        // set new element index sequentially, first element is 0, next is 1, etc.
        const new_element_index = parent.children('span').length;

        let new_span = document.createElement("span");
        new_span.id = buildSpanIndex(id_element, new_element_index);
        new_span.className = "btn edit";
        new_span.textContent = buildFunction(values);
        update_filled_values(id_element, values, "add");
        parent.append(new_span);
        let span_id = new_span.id;
        $(document).on('click', "#" + span_id.replaceAll(".", "\\\."), edit_);
        update_input_element(parent, id_element.replaceAll(".", "\\\."));
        $('#addModal').modal('hide');
        }
    }
};

$editForm= {
    "schema":{}, "form":[], value:{},
     onSubmit: function (errors, values) {
        if (errors) {
             flash("danger", errors[0].message);
        } else {
            console.log("In edit Click");
            if ( isValidaValues(values)){
                return
            }
            let id_element = $clicked.idUpdateElement.replaceAll(".", "\\\.");
            let element_span = $(`#${id_element}`);
            element_span.text(buildFunction(values));
            update_filled_values(remove_digits(id_element), values, "edit");
            update_input_element(element_span.parent(), remove_digits(id_element));
            $('#editModal').modal('hide');
        }
    }
}

function buildFlashMessage(type, text, msgId = null) {
    // create flash message alert with chosen type and text
    // add 'id' attribute to HTML element if it was provided
    let divSetup = `class="alert text-center alert-${type} alert-dismissible fade show" role="alert" style="display: none"`
    if (msgId) {
        divSetup += `  id=${msgId}`
    }
    const message = ` <div  ${divSetup}>${text}
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>`;
    return message;
}

function flash(type, text, slidedown=true) {
    const message = buildFlashMessage(type, text);
    $(".flashes").append(message);
    $($(".alert").last()).delay(100).slideToggle(1000);
    if (slidedown)
        $($(".alert").last()).delay(5000).slideToggle(1000);
}

function getActiveTab(){
    return $("div.filter_fields a.active").data()['data_type']
}

function filter_by_fields_type(e) {
    let text = e.options[e.options.selectedIndex].text;

    let active_tab = getActiveTab();
    let active_elements = $(`.${active_tab}`);

    switch (text) {
        case 'required' :
            active_elements.hide();
            $(`.${active_tab}.required`).show();
            break;
        case 'unmapped' :
            active_elements.show();
            for (let td_node of active_elements.children()) {
                if (td_node.querySelector('span.edit')) {
                   td_node.parentNode.style.display="none";
                }
            }
            break;
        default : // all
            active_elements.show();
            break;
    }
}

function setLastUpdatedContent(NewContent) {
    document.getElementById("last_edited_details").innerHTML = NewContent
}


function setMetadataDetails(metadataID, metadataLastEdited) {
    // set id and last edited details for applied metadata
    document.getElementById("metadata_id").innerText = metadataID;
    document.getElementById("metadata_last_edited").innerText = metadataLastEdited;
}

function nullifyLastUpdatedContent() {
    let lastEditedHTML = `last edited: <span id="last_edited" class="edited"><i></i><span class="date"></span><strong>Unknown</strong></span>`
    setLastUpdatedContent(lastEditedHTML)
}

function nullifyMetadataDetails() {
    setMetadataDetails("Unknown", "Unknown")
}

function setSchemaDetails(schemaName, schemaLastEdited) {
    // set name, and last edited details for effective schema
    document.getElementById("schema_name").innerText = schemaName;
    document.getElementById("schema_last_edited").innerText = schemaLastEdited;
}

function nullifySchemaDetails() {
    setSchemaDetails("Unknown", "Unknown")
}

function updateSchemaDetails(schemaName, schemaLastEdited){
    // set schema name and last edited details
    let lastEditedLocalized = parseDatetimeToLocal(schemaLastEdited);

    // if we have schema name set details
    if (schemaName) {
        setSchemaDetails(schemaName, lastEditedLocalized);
    } else {
        nullifySchemaDetails();
    }
}

function nullifyActiveTabMap(activeTab){
    // remove function-spans and in input values
    $(`.${activeTab} > td > span.edit`).remove();
    $(`.${activeTab} > td > input`).val(undefined);
}

function defineAndnullifyActiveTabMap(){
    let activeTab = getActiveTab();
    nullifyActiveTabMap(activeTab);
}

function refreshMapDetails(){
    // clean up content type specific values when user change the tab or metadata choice
    $("#local_map_status").hide();
    $("#deleted_rules_notification").addClass("d-none");
    content_type = null;
    content_sub_type = null;
    metadata_autocomplete_keys = [];
    map_edited_details = {};
    map_id = null;
    nullifyLastUpdatedContent();
    nullifyMetadataDetails();
    $populatedFields = {};
    $activeMap = {};
    $previousSavedMap = JSON.parse(JSON.stringify(($activeMap)));
    defineAndnullifyActiveTabMap();
    // set fields type filter to default value
    $('select#fields_kind').val('all').change();
}

function startSyncingSpinner(){
    $("#spin_sync_data").removeClass("d-none");
}

function stopSyncingSpinner(){
    $("#spin_sync_data").addClass("d-none");
}

function updateMetadataOptionsDropdown(targetAttr) {
    refreshMapDetails();
    nullifySchemaDetails();
    let newContentType;
    if (targetAttr) newContentType = targetAttr.slice(3);

    // find metadata options for this content type
    contentTypeMetadata = metadata_options[newContentType];

    // populate dropdown with metadata option
    let metadataSelect = document.getElementById("metadataSelect");

    // nullify previously selected options
    metadataSelect.innerHTML = "";

    // add default value
    let defaultOption = new Option('-',"");
    metadataSelect.add(defaultOption, undefined);

    // inform user if metadata for this type doesn't exists
    if (contentTypeMetadata.length === 0) {
        flash("warning", `No metadata available for "${newContentType}".`, slidedown=false);
    }
    for (let i = 0; i < contentTypeMetadata.length; i++){
        let metadataElement = contentTypeMetadata[i];
        let optionElement = document.createElement("option");
        optionElement.setAttribute('data-content_type', metadataElement.content_type);
        optionElement.setAttribute('data-content_sub_type', metadataElement.content_sub_type);

        let optionDisplayText = metadataElement.class_name;
        if (metadataElement.class_name !== metadataElement.resource_name) {
            optionDisplayText = `${metadataElement.resource_name} - ${metadataElement.class_name}`;
        }
        optionElement.appendChild(document.createTextNode(optionDisplayText));
        metadataSelect.appendChild(optionElement);
      }
}

function parseDatetimeToLocal(serverDatetime){
    const UTCMark = "Z";
    const parsedDate = new Date(serverDatetime + UTCMark);
    const parsedDateLocalized = (parsedDate.toLocaleDateString() + " " + parsedDate.toLocaleTimeString());
    return parsedDateLocalized
}

function updateLastEditedDetails(lastEditedDetails){
    // set map last edited details
    let lastEditor = lastEditedDetails["author"];
    let lastEdited = lastEditedDetails["updated_at"];

    let lastEditedLocalized = parseDatetimeToLocal(lastEdited);

    // if we have author set edited details
    if (lastEditor) {
        let lastEditedHTML = `last edited: <span id="last_edited"  class="edited"><i>${lastEditedLocalized}</i><span class="date"></span> by <strong>${lastEditor}</strong></span>`
        setLastUpdatedContent(lastEditedHTML);
    } else {
        nullifyLastUpdatedContent();
    }
}

function updateMetadataDetails(metadataID, metadataLastEdited){
    // set metadata id and last edited details
    let lastEditedLocalized = parseDatetimeToLocal(metadataLastEdited);

    // if we have metadata id set edited details
    if (metadataID) {
        setMetadataDetails(metadataID, lastEditedLocalized);
    } else {
        nullifyMetadataDetails();
    }
}

const fieldsToIgnore = ['source_id', 'csrf_token'];


function filterFormFields(form_params) {
    let form_params_arr = JSON.parse(form_params);
    let filledFields = {};
    for (let i = 0; i < form_params_arr.length; i++){
        let key = form_params_arr[i].name;
        let value = form_params_arr[i].value;
        if (value !== "" && !fieldsToIgnore.includes(key)) {
            filledFields[key] = value;
        }
    }
    return filledFields;
}

function resetForm() {
    let filteredFields = filterFormFields(JSON.stringify($("#form").serializeArray()));
    Object.keys(filteredFields).forEach(function (id) {
        let safeId = id.replaceAll(".", "\\\.");
        update_input_element($(`#${id}`).parent(), remove_digits(safeId));
        $(`[id^="${safeId}_"]`).remove();
    });
}

function createMorphStages(inputName, currentElement){
    let inputDisplayText = "";
    for (let n= 0; n<currentElement.func.length; n++ ){
      // nullify display text for each element do not concat names of the functions
      inputDisplayText = "";
      let params = [];
      Object.entries(currentElement.func_data[n].params).forEach(k => {
        params.push(`${k[0]}=${typeof k[1] === "object"? JSON.stringify(k[1]): k[1]}`)
      });
      inputDisplayText += `${currentElement.func[n]}(${params.join($ARG_ITEM_SEPARATOR)})`;
      let span_id = `${inputName}__${n}`;
      let span = `<span class="btn edit" id="${span_id}">${inputDisplayText}</span>`;
      $(`input[name=${inputName.replaceAll(".", "\\\.")}]`).parent().append(span);
      $(document).on('click', "#" + span_id.replaceAll(".", "\\\."), edit_);
    }
    //todo investigate ".." in properties names
    $(`input[name=${inputName.replaceAll(".", "\\\.")}]`).val(inputDisplayText);
}

function fillItemsMorphStages(activeTab, data, parentPath){
    // special function to populate .items fields
    morphs.forEach(morphStageName => {
        let currentStage = data[morphStageName];
        if (currentStage) {
            const inputName = `${activeTab.slice(3)}_${morphStageName}_${parentPath}`;
            createMorphStages(inputName, currentStage);
        }
    })
}

function updateMapWith(active_tab, data, parentPath="") {
    if (parentPath && parentPath.endsWith(".items")) {
        fillItemsMorphStages(active_tab, data, parentPath);
    }
  // recursively update items with active tab
  Object.keys(data).forEach(elementName => {
      let activeParentPath = parentPath.length ? `${parentPath}.${elementName}`.replaceAll("..", ".") : `${elementName}`;
        morphs.forEach(morph_name => {
            let currentElement = data[elementName]? data[elementName][morph_name]: data[elementName];

            if (currentElement && $activeMap[active_tab.slice(3)][activeParentPath]){
                let inputName = `${active_tab.slice(3)}_${morph_name}_${parentPath}${elementName}`;
                createMorphStages(inputName, currentElement);
                // //todo investigate ".." in properties names
                // $(`input[name=${inputName.replaceAll(".", "\\\.")}]`).val(inputDisplayText);
                $activeMap[active_tab.slice(3)][activeParentPath][morph_name] =
                        JSON.parse(JSON.stringify(currentElement))
            } else {
                // seems that items morphs are disabled by the code below, comment it temporary
                if (!activeParentPath.match(/items\.[a-zA-Z_$]+$/gm) &&
                    $activeMap[active_tab.slice(3)][activeParentPath]){
                        $activeMap[active_tab.slice(3)][activeParentPath][morph_name] = null
                }

            }
        })
            if (data[elementName] && data[elementName].items){
              updateMapWith(active_tab, data[elementName].items, activeParentPath + ".items" )
            }
            if (data[elementName] && data[elementName].properties){
                updateMapWith(active_tab, data[elementName].properties, activeParentPath + ".properties." )
            }
            if (elementName === "properties"){
              updateMapWith(active_tab, data[elementName], activeParentPath + ".")
            }
    })
}

function populateMapContent(mapProperties) {
    // set map with data from response
    let activeTab = getActiveTab();
    nullifyActiveTabMap(activeTab);
    updateMapWith(activeTab, mapProperties);
}

// compare DB rules with rules mentioned in the map to inform user if map rule was deleted
function displayDeletedRules(mapRulesNames) {
    const deletedRulesNames = mapRulesNames.filter(ruleName => !DBRulesNames.includes(ruleName));
    // if deleted rules were found - display info message for user
    if (deletedRulesNames.length > 0) {
        $("#deleted_rules_names").text(deletedRulesNames.join(', '));
        $("#deleted_rules_notification").removeClass("d-none");
    } else {
        // ensure that the message is hidden if deleted rules wasn't detected
        $("#deleted_rules_notification").addClass("d-none");
    }
}

function retrieveMorphMap(sourceId) {
    $.ajax({
        type: 'GET',
        url: (`/map/${sourceId}/${content_type}/${content_sub_type}`),
        contentType: 'application/json; charset=utf-8',
        dataType: 'json',
        success: function (responseData) {
            updateLastEditedDetails(responseData['map_edited_details']);
            map_id = responseData['map_id'];
            $populatedFields = responseData['filled_fields'];
            $activeMap = responseData['kw_map_raw'];
            $previousSavedMap = JSON.parse(JSON.stringify(($activeMap)));

            if (responseData['map_getting_error']){
                flash('info', responseData['map_getting_error'], slidedown=false);
            }

            populateMapContent(responseData['map_properties']);
            displayDeletedRules(responseData['map_rules_names']);
            stopSyncingSpinner();

            showSavedLocalMapInfo(sourceId, content_type, content_sub_type);
        },
        error: function (responseData) {
            console.log('An error occurred during map loading');
            console.log(responseData);
            flash('danger', `Cannot load map with content_type=${content_type} and content_sub_type=${content_sub_type}`, slidedown=false);
            stopSyncingSpinner();
        },
    });
}

/**
 * Find difference between current map and last unsaved changes from Local storage.
 * @param  {Number} sourceId       The current source ID
 * @param  {String} contentType    The current KW content type
 * @param  {String} contentSubType The current KW content sub-type
 * @return {Array}                 [Local changes, Date of changes]
 */
function getLocalMapDiff(sourceId, contentType, contentSubType) {
    let localChanges = {}, changesDate = null;

    if (!isMetadataSelected()) {
      return [localChanges, changesDate];
    };

    let localMap = getLocalMap(sourceId, contentType, contentSubType);
    if (!localMap) {
        return [localChanges, changesDate];
    };
    changesDate = localMap["updated_at"];
    localMap = localMap["map"];

    let currentMap = $activeMap[contentType];
    Object.keys(currentMap).forEach(function (fieldPath) {
        Object.keys(currentMap[fieldPath]).forEach(function (morphStage) {
            let activeFuncs = currentMap[fieldPath][morphStage];
            if (localMap[fieldPath]){
                let localFuncs = localMap[fieldPath][morphStage];
                if (JSON.stringify(localFuncs) !== JSON.stringify(activeFuncs)) {
                    localChanges[fieldPath] = {}
                    if (localFuncs) {
                        let strFuncs = []
                        for (let i= 0; i< localFuncs.func.length; i++){
                            strFuncs.push(buildSpanFunction(localFuncs, i));
                        };
                        localChanges[fieldPath][morphStage] = strFuncs.join($FUNC_ITEM_SEPARATOR)
                    } else {
                        localChanges[fieldPath][morphStage] = null
                    }

                };
            };
        });
    });
    return [localChanges, changesDate];
}

function showSavedLocalMapInfo(sourceId, contentType, contentSubType) {
    $("#local_map_status").hide();
    let [localChanges, changesDate] = getLocalMapDiff(sourceId, contentType, contentSubType);
    if (Object.keys(localChanges).length > 0) {
        $("#local_map_status").removeClass("d-none");
        $("#local_map_date").text(changesDate);
        $("#local_map_changes").text(JSON.stringify(localChanges, null, 2));
        $("#local_map_status").show();
    }
}

function applyNewMetadata(metadataOption) {
    // if user change metadata choice it's required:
    // 1. download new metadata
    // 2. pass new metadata to dropdown options
    // 3. set metadata details on the page
    // 4. download map based on metadata choice
    // 5. apply new map on the page
    // 6. set map updated details

    startSyncingSpinner();
    // clean up previous choices
    refreshMapDetails();

    // retrieve chosen metadata
    let selectedOption = metadataOption.options[metadataOption.options.selectedIndex];
    let text = metadataOption.options[metadataOption.options.selectedIndex].text;
    content_type = selectedOption.dataset.content_type;
    content_sub_type = selectedOption.dataset.content_sub_type;
    if (!content_type && !content_sub_type){
        stopSyncingSpinner();
        return
    }
    const sourceId = $('input[name*=source_id]')[0].value;

    // retrieve metadata
    $.ajax({
        type: "GET",
        url: (`/metadata/${sourceId}/${content_type}/${content_sub_type}`),
        contentType: "application/json; charset=utf-8",
        dataType: "json",
        success: function (responseData) {
            metadata_autocomplete_keys = responseData["metadata_options"];
            if (responseData["metadata_getting_error"]){
                flash("info", responseData["metadata_getting_error"], slidedown=false);

            }
            updateMetadataDetails(responseData["id"], responseData["last_edited"]);
        },
        error: function (responseData) {
            console.log('An error occurred during metadata loading');
            console.log(responseData);
            flash("danger", `Cannot load metadata with content_type=${content_type} and content_sub_type=${content_sub_type}`, slidedown=false);
            stopSyncingSpinner();
        },
    });

    // get corresponding map
    retrieveMorphMap(sourceId);
}

function filter_fields(target) {
    $(`.master_schema`).hide();
    $(`.${target.dataset.data_type}`).show();
    $("div.filter_fields a.active").removeClass("active");
    $(target).addClass("active");
    $('select#fields_kind').val('all').change();

    // update metadata dropdown options
    updateMetadataOptionsDropdown(target.dataset.data_type);

    // update schema details
    let active_tab = getActiveTab();
    if (active_tab) active_tab = active_tab.slice(3);
    const schema = masterSchemas[active_tab];
    const schema_name = subSchemaNameMap[active_tab]
    updateSchemaDetails(schema_name, schema['updated_at']);
}


function update_input_element(parent, elementId) {
    let functionsTextContent = Array.from(parent.children("span"), span => span.textContent);
    $(`input[name=${elementId}]`).val(functionsTextContent.join($FUNC_ITEM_SEPARATOR));
}

function isAllRequiredFieldsFilled(form, active_tab, errorMessagesContainer) {
    console.log("Check required for tab save");
    let required_not_filled = [];

    let rows = form.find(`tr.required.kw_${active_tab}`);
    for( let item= 0; item < rows.length; item++){
        let cells = rows[item].children;
        let is_filled = false;
        let tab_name = rows[item].className.match(/kw_(\w+)/)[1];
        for (let i = 1; i < cells.length; i++) {
            if (cells[i].getElementsByTagName('input') &&
                cells[i].getElementsByTagName('input')[0].value) {
                is_filled = true
            }
        }
        if (!is_filled) {
            let field_name = rows[item].className.match(/\S*$/)[0];
            required_not_filled.push(tab_name + field_name);
            let message = `The field <b>${field_name}</b> on <b>${tab_name} </b> tab is not filled`;
            $(errorMessagesContainer).append(get_message_template("danger", message));
        }
    }
    return required_not_filled.length;
}

function data_for_autocomplete(dataset) {
    if (dataset.kind === 'mapper') {
        return metadata_autocomplete_keys;
    }
    let fields_and_description = [];
    let cc = $(`.kw_${dataset.metadata_type}`)
    cc.each( i => {
        fields_and_description.push(cc[i].classList.value.split(" ").pop())
    })
    return fields_and_description;
}

function collectForSave(tabFields) {
    let dataStr = "";
    for (key of Object.keys(tabFields)){
        dataStr += `${key}=${tabFields[key]}&`;
    }
    return dataStr;
}

function getDiff(currentMap, previousMap) {
    // function return difference between activeTabFields and populatedValues
    let rez = {}
    Object.keys(currentMap).forEach((field) => {
        if (JSON.stringify(previousMap[field]) !== JSON.stringify(currentMap[field]))
            rez[field] = JSON.parse(JSON.stringify(currentMap[field]));
    })
    return rez;
}

function updateModalForm(fooObj, formObj, formId="addForm", values={}, morphType = null) {
    formObj.value.func_name = fooObj.name;
    formObj.schema = {func_name : {
        type: "string", readonly:true, title: "Function:",
        description: fooObj.description,
    }}
    formObj.form = ["func_name"];
    fooObj.params.forEach(param => {
        formObj.schema[param.name] = {
            type: param.types.includes("int") ? "number":"string" ,
            description: param.description,
            required: param.default === undefined,
            };
        // provide default values in form
        if (param.default !== undefined && param.default !== null)
            formObj.value[param.name] =
                typeof(param.default)==="string"? param.default: JSON.stringify(param.default);
        formObj.form.push(param.name);
    })
    Object.keys(values).forEach(key => {formObj.value[key] =
        typeof(values[key])==="string"? values[key]: JSON.stringify(values[key])
    })

    // for rules add expandable section to view the rule body
    if (morphType === 'rule') {
        const ruleBodyElementName = 'rule_body';
        formObj.schema[ruleBodyElementName] = { type: 'string', title: 'Function body:', readonly: true };
        formObj.value[ruleBodyElementName] = fooObj.content;
        formObj.form.push({ type: 'textarea', key: ruleBodyElementName, htmlClass: 'rule-content' });
    };

    if (formId === "addForm")
        formObj.form.push({"type": "submit", "title": "Create", "htmlClass": "float-right"});
    else {
      // edit form
      formObj.form.push({type: 'submit', title: 'Update', 'htmlClass': 'float-right'})
      formObj.form.push({type: 'button', title: 'Delete', htmlClass: 'float-right', onClick: deleteBtnClick})
    }

    $(`#${formId} > div`).remove();
    $(`#${formId}`).jsonForm(formObj);
    $("input[id*='jsonform']").autocomplete({ source: data_for_autocomplete($clicked)});
}

function deleteNotExistingMorphModal(funcName, morphName) {
    document.getElementById("deletedMorphInfo").innerHTML = `The ${morphName} "${funcName}" is not available anymore.`;
    $('#deleteModal').modal("show");
}

let edit_ = function on_edit(e) {
    console.log("In Edit");
    let eventTargetElement = e.currentTarget;
    $clicked = $(eventTargetElement).parent().children().filter("div").children()[0].dataset;
    $clicked.idUpdateElement = eventTargetElement.id;

    // get index of clicked element by it's ID
    const elementIdParts = $clicked.idUpdateElement.split("__");
    $clicked.func_index = elementIdParts[1];

    // populate function object
    let funcName = eventTargetElement.textContent.split("(")[0];
    let info = getInfo(remove_digits(eventTargetElement.id));
    let rawFuncObj = $activeMap[info[0]][info[2]][info[1]];
    let argIndex = rawFuncObj.func.indexOf(funcName);
    let funcArgs = rawFuncObj["func_data"][argIndex]['params'];

    let funcBody = "";
    meta_map[$clicked.kind].forEach(i => {
        if (i.name === funcName){
            funcBody = i;
        }
    });
    // if we didn't find such morph, serve modal to delete it completely
    if (!funcBody) {
        deleteNotExistingMorphModal(funcName, $clicked.kind);
        return
    }
    updateModalForm(funcBody, $editForm, "editForm", funcArgs, $clicked.kind);
    $('#editModal').modal("show");
}

// iterate through parent element nested spans and ensure that indexes are sequential
function updateUISpansIndexes(parent, fieldId) {
    const spans = parent.children('span');
    for (let newIndex = 0; newIndex < spans.length; newIndex++){
        spans[newIndex].id = buildSpanIndex(fieldId, newIndex);
    }
}

function _deleteMorph() {
    // process morph deletion from UI and local map object
    let id = $clicked.idUpdateElement;
    let id_element = $(`#${id.replaceAll(".", "\\\.")}`);
    let parent = id_element.parent();
    update_filled_values(remove_digits(id), {func_index: $clicked.func_index}, "delete");
    id_element.remove();
    update_input_element(parent, remove_digits(id.replaceAll(".", "\\\.")));

    // update rest of children elements to have proper UI indexes
    updateUISpansIndexes(parent, remove_digits(id));
}

// click delete from edit form
function deleteBtnClick() {
    console.log("in update Delete");
    _deleteMorph();
    $('#editModal').modal('hide');
}

// click delete from delete form
function deleteFormDeleteBtnClick() {
    _deleteMorph();
    $('#deleteModal').modal('hide');
}

// helper function for remove number from id
function remove_digits(name) {
        return name.replace(/__\d+$/, '');
}

function updateRevertWindow(text=""){
  if (text.length === 0 ){
      $("#revertInfo").text("");
      $('#applyMap').prop( "disabled", true);
  } else {
      $("#revertInfo").text(text);
      $('#applyMap').prop( "disabled", false);
  }
}

function isMetadataSelected() {
    // check if metadata is selected
    if (!content_type || !content_sub_type){
        flash("info", "Please, choose metadata.", slidedown=false);
        return false;
    }
    return true;
}

function revertMapButtonClick(){
    if (!isMetadataSelected()) {
        return;
    };
    let active_tab = getActiveTab();
    if (active_tab) active_tab = active_tab.slice(3);

    // parse schema version details to display it in the revert pop-up
    const schema = masterSchemas[active_tab];
    const schemaVersion = schema['version'];
    const schemaUpdatedAt = parseDatetimeToLocal(schema['updated_at']);

    let source_id = $('input[name*=source_id]')[0].value;
    let dataTable = $('#mapsList').DataTable();
    dataTable.clear().draw();
    dataTable.ajax.url(`/saved_maps/${source_id}/${content_type}/${content_sub_type}?map_id=${map_id}`);
    dataTable.ajax.reload(function (json) {
        // show columns when data was returned
        if (json["data"].length !== 0) {
            dataTable.columns([0, 1]).visible(true);
        }
    });
    updateRevertWindow();
    $(`#revertModalTitle`).text(`List of maps for ${active_tab}`);
    $(`#revertModalSchemaDetailsVersion`).text(`Schema version: ${schemaVersion}`);
    $(`#revertModalSchemaDetailsUpdatedAt`).text(`Updated at: ${schemaUpdatedAt}`);
    $("#revertModal").modal("show");
}


function collectInfoAboutRevertObj(data, path="") {
    let functions = [];
    Object.keys(data).forEach(obj => {
        functions.push(path+obj);
        if (data[obj].items && data[obj].items.properties){
            functions.push(...collectInfoAboutRevertObj(data[obj].items.properties,
                                                        path + `${obj}.items.properties.`))
        }
    })
    return functions;
}

function getInfo(key) {
    let sub_map = null, morph = null;
    Object.keys($populatedFields).forEach(sub_m => {
        if (key.startsWith(sub_m)) sub_map = sub_m
    });
    morphs.forEach(morph_ => {
        if (key.slice(sub_map.length+1).startsWith(morph_))  morph = morph_});
    let field = key.slice(`${sub_map}_${morph}_`.length).replaceAll("\\", "");
    return [sub_map, morph, field];
}

function getElementPath(contentType, morphStage, fieldPath){
   return [contentType, morphStage, fieldPath].join($KEY_SEPARATOR)
}


function getLocalMapKey(sourceId, contentType, contentSubType) {
    return [sourceId, contentType, contentSubType].join($KEY_SEPARATOR)
}

function storeLocalMap(sourceId, contentType, contentSubType) {
    let localMaps = JSON.parse(localStorage.getItem("local_map"));
    if (!localMaps){
        localMaps = {}
    };
    localMaps[getLocalMapKey(sourceId, contentType, contentSubType)] = {
        "map": $activeMap[contentType],
        "updated_at": new Date().toString()
    };
    localStorage.setItem("local_map", JSON.stringify(localMaps));
}

function getLocalMap(sourceId, contentType, contentSubType) {
    let localMaps = JSON.parse(localStorage.getItem("local_map"));
    let mapKey = getLocalMapKey(sourceId, contentType, contentSubType);
    if (localMaps && localMaps[mapKey]) {
        return localMaps[mapKey]
    };
}

function removeLocalMap(sourceId, contentType, contentSubType) {
    let localMaps = JSON.parse(localStorage.getItem("local_map"));
    let mapKey = getLocalMapKey(sourceId, contentType, contentSubType)
    if (localMaps && localMaps[mapKey]) {
        delete localMaps[mapKey]
        localStorage.setItem("local_map", JSON.stringify(localMaps));
    }
}

function validateMapButtonClick(){
    // open "validate map" modal window
    if (!isMetadataSelected()) {
        return;
    }
    $("#validateMapModal").modal("show");
}

function unblockRunMorphButton() {
    // block/unblock the "Run Morph" button depending on the text input
    if($("#inputDataTextArea").val().trim().length < 1) {
        $('#runMorphButton').attr('disabled','disabled');
    } else {
        $('#runMorphButton').removeAttr('disabled');
    }
}

function cleanUpMapValidationModalButtonClick() {
    // clean up inputs
    document.getElementById("inputDataTextArea").value = "";
    document.getElementById("processedDataTextArea").value = "";
    document.getElementById("validateMapModalMessages").innerHTML = "";
    // disable actions related buttons
    $('#runMorphButton').attr('disabled','disabled');
    // remove data elements
    const processIdContainer = document.getElementById('executionLogsHeader');
    delete processIdContainer.dataset.processId;
    delete processIdContainer.dataset.page;
    delete processIdContainer.dataset.attempsMade;
    document.getElementById("logsList").innerHTML = "";
}

function getMapActiveTab(form, errorMessagesContainer){
    const activeElement = $("div.filter_fields a.active").data();
    if (!activeElement){
        alert("Please refresh your page.");
        return;
    }
    const activeTab = activeElement['data_type'].match(/kw_(\w+)/)[1];
    if (isAllRequiredFieldsFilled(form, activeTab, errorMessagesContainer)) {
        return;
    }
    return activeTab;
}


function buildNewMapRequestData(activeTab, sourceId){
    // create map data object for request
    let data = JSON.parse(JSON.stringify($activeMap[activeTab]));
    data['source_id'] = sourceId;
    data['map_version'] = map_id;
    data['is_ajax'] = true;
    data['content_type'] = content_type;
    data['content_sub_type'] = content_sub_type;
    return data
}

function flashInModal(type, text, msgId = null) {
    const message = buildFlashMessage(type, text, msgId);
    $(".flashes-modal").append(message);
    $($(".alert").last()).delay(100).slideToggle(1000);
}


function isJsonString (jsonString){
    // validate that input data is a properly formatted dict
    try {
        const jsonObj = JSON.parse(jsonString);
        if (jsonObj && typeof jsonObj === "object" && jsonObj.constructor == Object) {
            return true;
        }
    }
    catch (e) { }

    return false;
}

const addLogsToTheContainer = function(data) {
    const logsItemsContainer = document.querySelector('#logsList');
    data.forEach((logItem) => {
        const item = document.createElement('li');
        item.innerText = `${logItem["created_at"]}:${logItem["text_payload"]}`;
        logsItemsContainer.appendChild(item)
    })
}

function parseServerErrors(responseData) {
    // parse responseData for user-friendly error message if it exists
    let errorMessage = ""
    try {
        errorMessage = responseData.responseJSON['error']
    } catch (e) {
        console.log("Cannot parse error message", e);
        errorMessage = `An error has occurred: ${responseData.status} ${responseData.statusText}`
    }
    return errorMessage
}

function updateCountdownMsg(msgId, text){
    document.getElementById( `${msgId}`).innerHTML = text;
}

function retryLogsRetrieving(seconds, processId) {
    // display countdown in flash message to notify user about new logs getting attempt
    const countdownFlashMsgId = `retryLogsRetrievingCountdown${processId}`;
    const retryTimer = setInterval(function () {
        if (seconds > 0) {
            const countdownText = `Logs by the process_id ${processId} are not available yet, retry to request them again in ${seconds} seconds`;
            if (document.getElementById(`${countdownFlashMsgId}`)) {
                updateCountdownMsg(countdownFlashMsgId, countdownText)
            } else {
                flashInModal("info", countdownText, countdownFlashMsgId)
            }
            seconds--;
        } else {
            updateCountdownMsg(countdownFlashMsgId,`Making 2nd attempt to retrieve logs by process_id ${processId}`);
            clearInterval(retryTimer);
            retrieveLogsRequest();
        }
    }, 1000);
}

function retrieveLogsRequest() {
    // request morph execution logs by process id and display it
    const logsDetailsContainer = document.getElementById('executionLogsHeader');
    const processId = logsDetailsContainer.dataset.processId;
    let page = logsDetailsContainer.dataset.page;
    if (!processId) {
        flashInModal("danger", "Unable to retrieve logs: no 'process_id' found");
        return
    }
    // pass default page number if it's not set yet
    if (!page) {
        page = 1
    }
    $("#retrieveLogsSpinner").removeClass("d-none");

    $.ajax({
        type: "GET",
        url: ("/map/validate"),
        data: {
            "process_id": processId, "page": page
          },
        contentType: "application/json; charset=utf-8",
        success: function (responseData) {
            // handle case if logs associated with the process id not found
            const logsData = responseData["data"];
            if (!logsData.length && page === 1) {
                // if this is first logs getting attempt, show info message and retry in 1min
                // otherwise, show message that logs are not available
                let attempsMade = logsDetailsContainer.dataset.attempsMade;
                if (!attempsMade) {
                   attempsMade = 1
                }
                if (attempsMade > 1) {
                    flashInModal("warning", `Logs by the process_id ${processId} are not available in BQ.`);
                } else {
                    attempsMade++;
                    document.getElementById('executionLogsHeader').dataset.attempsMade = attempsMade;
                    retryLogsRetrieving(60, processId);
                }
            }

            if (logsData.length) {
                // display results data to the logs section
                addLogsToTheContainer(logsData);

                // increase processed page number and save it
                page++;
                document.getElementById('executionLogsHeader').dataset.page = page++;
            }

            $("#retrieveLogsSpinner").addClass("d-none");
        },
        error: function (responseData) {
            console.log("Error", responseData);
            flashInModal("danger", parseServerErrors(responseData));
            $("#retrieveLogsSpinner").addClass("d-none");
        },
    });
}

function runMorphButtonClick(){
    // Get input data from input area and the latest map from the page
    // Call Morph endpoint and display results
    const inputData = $("#inputDataTextArea").val();
    if (!isJsonString(inputData)){
        flashInModal("danger", "Input Data should be a properly formatted JSON");
        return
    }

    let form = $("#form");
    let activeTab = getMapActiveTab(form, ".flashes-modal");

    let formData = Object.fromEntries(new FormData(form[0]));
    const sourceId = formData['source_id'];
    const data = buildNewMapRequestData(activeTab, sourceId);

    $("#runMorphSpinner").removeClass("d-none");
    const requestPayload = {"map": data, "payload": JSON.parse(inputData)};

    $.ajax({
        type: "POST",
        url: "/map/validate",
        contentType: "application/json; charset=utf-8",
        dataType: "json",
        data: JSON.stringify(requestPayload),
        beforeSend: function(xhr){xhr.setRequestHeader('X-CSRFToken', formData['csrf_token']);},
        success: function (responseData) {
            if ("result" in responseData && responseData["result"] === "success") {
                // parse response data
                const processId = responseData["data"]["process_id"];
                const result = responseData["data"]["result"];
                const status = responseData["data"]["status"];

                // show execution result it the corresponding section
                document.getElementById("processedDataTextArea").value = JSON.stringify(result, null, 4);

                // show message about execution status
                const executionStatusMessage = `Morph execution completed with status '${status}' (process_id=${processId})`;
                const flashMessageType = status === "success" ? "success" : "danger";
                flashInModal(flashMessageType, executionStatusMessage);

                $("#runMorphSpinner").addClass("d-none");

                // set process id to data attributes and start logs downloading, nullify retry counter attempts
                const processIdContainer = document.getElementById('executionLogsHeader');
                processIdContainer.dataset.processId = processId;
                delete processIdContainer.dataset.attempsMade;
                retrieveLogsRequest();
            }
        },
        error: function (responseData) {
            console.log("Error", responseData);

            flashInModal("danger", parseServerErrors(responseData));
            $("#runMorphSpinner").addClass("d-none");
        },
    });
}

function downloadJsonFile(filename, dataObjToWrite) {
    const blob = new Blob([JSON.stringify(dataObjToWrite)], { type: 'text/json' });

    // create link element with downloadable content
    const link = document.createElement('a');
    link.download = filename;
    link.href = window.URL.createObjectURL(blob);
    link.dataset.downloadurl = ['text/json', link.download, link.href].join(':');

    // perform click action to trigger downloading
    const clickEvent = new MouseEvent('click', {
        view: window,
        bubbles: true,
        cancelable: true,
    });
    link.dispatchEvent(clickEvent);

    // cleanup recently created link
    link.remove();
}

function disableActionButtons() {
    $('#btn_save_map, #btn_apply_local_map, #btn_reset_form, #btn_promote_map, #btn_revert_map, #btn_validate_map, #btn_export_map, #btn_import_map').attr('disabled', 'disabled');
}

function enableActionButtons() {
    $('#btn_save_map, #btn_reset_form, #btn_apply_local_map, #btn_promote_map, #btn_revert_map, #btn_validate_map, #btn_export_map, #btn_import_map').removeAttr('disabled');
}

function exportMapButtonClick() {
    // build map based on UI form and download it to json
    if (!isMetadataSelected()) {
        return;
    }

    const form = $('#form');
    const activeTab = getMapActiveTab(form, '.flashes');

    const formData = Object.fromEntries(new FormData(form[0]));
    const sourceId = formData['source_id'];
    const data = buildNewMapRequestData(activeTab, sourceId);

    $('#spin_save_map').removeClass('d-none');
    disableActionButtons();

    $.ajax({
        type: 'POST',
        url: '/map/export',
        contentType: 'application/json; charset=utf-8',
        dataType: 'json',
        data: JSON.stringify({'map': data}),
        beforeSend: function(xhr){xhr.setRequestHeader('X-CSRFToken', formData['csrf_token']);},
        success: function (responseData) {
            if ('result' in responseData && responseData['result'] === 'success') {
                // get generated map
                const generatedMap = responseData['data'];

                // generate filename as combination of content type, content subtype, source ID and user local datetime
                const filename = `${content_type}-${content_sub_type}-${sourceId}-${new Date().toLocaleString()}.json`;
                downloadJsonFile(filename, generatedMap);
                $('#spin_save_map').addClass('d-none');
                enableActionButtons();
            }
        },
        error: function (responseData) {
            console.log('Error', responseData);
            flash('danger', parseServerErrors(responseData));
            $('#spin_save_map').addClass('d-none');
            enableActionButtons();
        },
    });
}

function importMapOpenModal() {
    // open "import map" modal window
    if (!isMetadataSelected()) {
        return;
    }
    $('#importMapModal').modal('show');
}

function applyImportedMap(data, fileName){
    const form = $('#form');
    const formData = Object.fromEntries(new FormData(form[0]));
    const sourceId = formData['source_id'];

    $('#spin_save_map').removeClass('d-none');
    disableActionButtons();
    data['content_type'] = content_type;
    data['content_sub_type'] = content_sub_type;
    data['source_id'] = sourceId;

    $.ajax({
        type: 'POST',
        url: '/map/import',
        contentType: 'application/json; charset=utf-8',
        dataType: 'json',
        data: JSON.stringify(data),
        beforeSend: function(xhr){xhr.setRequestHeader('X-CSRFToken', formData['csrf_token']);},
        success: function (responseData) {
            $populatedFields = responseData['filled_fields'];
            $activeMap = responseData['kw_map_raw'];

            populateMapContent(responseData['map_properties']);
            flash('info', `Applied map from the file ${fileName}`, false);

            $('#spin_save_map').addClass('d-none');
            enableActionButtons();

        },
        error: function (responseData) {
            console.log('Error', responseData);

            flash('danger', parseServerErrors(responseData), false);
            $('#spin_save_map').addClass('d-none');
            enableActionButtons();
        },
    });
}

function importMapButtonClick() {
    // process file uploading
    const uploadInput = document.getElementById('importingMapFile');

    // validate if file was chosen
    if (!uploadInput.files.length) {
        alert('Please, choose file first.');
        return;
    }

    const fileName = uploadInput.files[0].name;

    // read the file
    const reader = new FileReader();
    // This event listener will happen when the reader has read the file
    reader.addEventListener('load', function() {
        // Parse the result into an object
        const result = JSON.parse(reader.result);
        applyImportedMap(result, fileName);
    });

    // Read the uploaded file
    reader.readAsText(uploadInput.files[0]);

    // clean up input and hide modal
    uploadInput.value = '';
    $('#importMapModal').modal('hide');
}

$(document).ready(function () {
    // apply listing map filtering by default
    if (!window.location.hash) {
        window.location.href = window.location.href + "#no-filter";
    }

    // infinite list for logs loading
    const logsItemsContainer = document.querySelector('#logsList');

    // Detect when logs section scrolled to the bottom
    logsItemsContainer.addEventListener('scroll', function() {
        if (logsItemsContainer.scrollTop && (logsItemsContainer.scrollTop + logsItemsContainer.clientHeight >= logsItemsContainer.scrollHeight)) {
            retrieveLogsRequest();
        }
    });


     $("#mapsList").DataTable({
          'ajax': "",
          "scrollY": "50vh",
          "scrollCollapse": true,
          "iDisplayLength": 10,
          order: [[1, "desc"]],
          processing: true,
          columns: [
              // hide columns during loading to not break the layout
              {data: "author", title: "Author", orderable: false, visible: false},
              {data: "updated_at", title: "Saved at", visible: false, render: function (data, type) {
                  let d = new Date(data);
                  return type === "display" ?d.toLocaleDateString() + " "+ d.toLocaleTimeString(): d
               }},
          ],
         "language": {
             "emptyTable": "There are no previous maps available.",
             "processing": "Loading..."
         }
    });

    $('#mapsList tbody').on( 'click', 'tr', function () {
        if ( $(this).hasClass('selected') ) {
           $(this).removeClass('selected');
           updateRevertWindow();
        }
        else {
           $('#mapsList').DataTable().$('tr.selected').removeClass('selected');
           $(this).addClass('selected');
           let data= $("#mapsList").DataTable().row('.selected').data();
           updateRevertWindow(collectInfoAboutRevertObj(data?.properties || {}).join($ARG_ITEM_SEPARATOR+ " "));
        }
    } );

    $('#applyMap').click( function () {
        let dataToAppy = $("#mapsList").DataTable().row('.selected').data();
        let active_tab = getActiveTab();

        // remove function-spans and in input values
        $(`.${active_tab} > td > span.edit`).remove();
        $(`.${active_tab} > td > input`).val(undefined);

        updateMapWith(active_tab, dataToAppy.properties);
        $("#revertModal").modal("hide");

    } );

    $('select#fields_kind').val('all').change();

    // rules adding pop-up autocomplete
    const rulesFilteringInput = $('input#rulesAutocomplete');
    const groupsFilteringInput = $('input#groupsAutocomplete');

    function findRulesNamesMatches(search, options) {
      return options.filter((option) => {
        const regex = new RegExp(search, "gi");
        return option.text.match(regex);
      });
    }

    let rulesNamesOptions = [];
    let groupsNamesOptions = [];

    function filterRulesNamesOptions() {
      const select = $('select#foo');
      rulesNamesOptions.forEach((option) => {
        option.remove();
        option.selected = false;
      });
      const matchArray = findRulesNamesMatches(this.value, rulesNamesOptions);
      select[0].append(...matchArray);
    }

    function filterGroupsNamesOptions() {
      const select = $('select#ruleGroups');
      groupsNamesOptions.forEach((option) => {
        option.remove();
        option.selected = false;
      });
      const matchArray = findRulesNamesMatches(this.value, groupsNamesOptions);
      select[0].append(...matchArray);
    }

    rulesFilteringInput[0].addEventListener('change', filterRulesNamesOptions);
    rulesFilteringInput[0].addEventListener('keyup', filterRulesNamesOptions);
    groupsFilteringInput[0].addEventListener('change', filterGroupsNamesOptions);
    groupsFilteringInput[0].addEventListener('keyup', filterGroupsNamesOptions);

    // click add
    $('.add').on('click', function (e) {
        console.log("In Add");
        $("#addForm > div").remove();
        let current_element = e.currentTarget;

        $clicked = current_element.dataset;
        let select_elem_groups = $('select#ruleGroups');
        select_elem_groups.empty();
        if (current_element.dataset.kind !== "rule"){
            $("div#groups").hide();
            $("div#rulesAutocompleteDiv").hide();
            $("#ruleGroups").empty();
        } else {
            $("div#rulesAutocompleteDiv").show();
            $("div#groups").show();
        };
        let select_elem_foo = $('select#foo');
        select_elem_foo.empty();
        let selectOptionsCount = 0;
        for (let item in meta_map[current_element.dataset.kind]) {
            let option_element = document.createElement('option');
            option_element.value = item;
            option_element.dataset.kind = current_element.dataset.kind;
            option_element.innerHTML = meta_map[current_element.dataset.kind][item].name;
            option_element.className = "opt";
            for (let gr of meta_map[current_element.dataset.kind][item].groups || []){
                option_element.classList.add(gr);
                if (!select_elem_groups.find(`#group_${gr}`).length)
                    select_elem_groups.append(
                        `<option value="${gr}" id="group_${gr}" class="group">${gr}</option>`
                        );
            }
            select_elem_foo.append(option_element);
            selectOptionsCount += 1;
        }

        // make rules pop-up box adoptive to number of rules,
        // if there are more than 10 rules max it 10 lines long, else make it 7
        if (current_element.dataset.kind === "rule"){
            rulesNamesOptions = Array.from(select_elem_foo[0].options);
            groupsNamesOptions = Array.from(select_elem_groups[0].options);
            const selectSize = selectOptionsCount > 10 ? 10 : 7;
            select_elem_foo.attr("size", selectSize);
        } else {
            // keep default size for the rest of morph stages
            select_elem_foo.attr("size", 5);
        }
        $('#addModal').modal('show');
    });

    $('#ruleGroups').on('change', function() {
            let selected_values = $('#ruleGroups').val();
            if (selected_values.length) {
                $('.opt').hide();
                $(`select#foo`).val('');
                $('form#addForm').empty();
            } else
                $('.opt').show();

            selected_values.forEach(gr=> {$(`.opt.${gr}`).show()});
        });

    $('select#foo').on('click change select scroll', function (e) {
        if (e.target.value === "") {
            return;
        }
        let value = e.target.value;
        let kind = e.target.dataset.kind || e.target.options[value].dataset.kind;
        let fooObj = meta_map[kind][value];
        updateModalForm(fooObj, $addForm, 'addForm', {}, kind);
    });

    // click edit
    $('.btn.edit').on('click', edit_);

    $(".description_control").on('click', function (e) {
        let desc_elem = e.currentTarget.parentNode.getElementsByClassName("description");
        if (e.currentTarget.innerHTML.startsWith("+")) {
            $(desc_elem).show();
            e.currentTarget.innerHTML = '-\n <span class="tooltip_description">Collapse</span>\n';
        } else {
            $(desc_elem).hide();
            e.currentTarget.innerHTML = '+\n<span class="tooltip_description">Expand</span>\n';
        }
    });

    // save map
    $("#form").submit(function (e) {
        e.preventDefault(); // avoid to execute the actual submit of the form.

        if (!isMetadataSelected()) {
            return;
        };

        let form = $(this);
        const activeTab = getMapActiveTab(form, ".flashes");

        let formData = Object.fromEntries(new FormData(e.target))
        let activeTabFields = {};
        for (let field of Object.keys(formData)){
            if (field.includes(activeTab)){
                activeTabFields[field] = formData[field]
            }
        }
        let diff = getDiff($activeMap[activeTab], $previousSavedMap[activeTab]);

        let isForceUpdate = false;
        if ((Object.keys(diff).length) === 0) {
            // if nothing changed allow user to save map anyway
            if (!confirm("There is no map changes.\n\nAre you going to make force map update to apply new schema version?")) {
                console.log("Skip force map update...");
                return;
            }
            isForceUpdate = true;
        } else if (!confirm(`Are you going to update ${Object.keys(diff).join(", ")} fields?`)) {
            console.log("Skip update...");
            return;
        }

        console.log("Updating... ");
        const sourceId = formData['source_id'];
        let data = buildNewMapRequestData(activeTab, sourceId);
        // define map saving specific fields
        data['force_update'] = isForceUpdate;

        storeLocalMap(sourceId, content_type, content_sub_type);

        disableActionButtons();
        $("#spin_save_map").removeClass("d-none");

        $.ajax({
            type: "POST",
            url: form.attr('action'),
            contentType: "application/json; charset=utf-8",
            dataType: "json",
            data: JSON.stringify(data),
            beforeSend: function(xhr){xhr.setRequestHeader('X-CSRFToken', formData['csrf_token']);},
            success: function (resp_data) {
                console.log("Updated!");
                if ("result" in resp_data && resp_data["result"] === "success") {
                    if ("message" in resp_data){
                        flash("info", resp_data["message"], slidedown=false);
                        enableActionButtons();
                        $("#spin_save_map").addClass("d-none");
                    } else {
                        retrieveMorphMap(sourceId);
                        enableActionButtons();
                        $("#spin_save_map").addClass("d-none");
                        flash('info', 'Saved map changes!', slidedown=true);
                    };
                    removeLocalMap(sourceId, content_type, content_sub_type);
                }
            },
            error: function (resp_data) {
                console.log('Error');
                enableActionButtons();
                $("#spin_save_map").addClass("d-none");
                flash("danger", parseServerErrors(resp_data), slidedown=false);

            },
        });
    });


    $("#promotion-form").submit(function (e) {
        e.preventDefault(); // avoid to execute the actual submit of the form.
        const form = $(this);
        const formData = Object.fromEntries(new FormData(e.target));
        const sourceId = formData['source_id'];
        if (!confirm(`Do you confirm maps and rules promotion for source ${sourceId} to the production environment?`)){
            console.log("Promotion rejected by user...");
            return;
        }
        console.log("Promotion in progress... ");

        const data = {
            'source_id': sourceId,
            'is_ajax': true
        };
        disableActionButtons();
        $("#spin_promote_map").removeClass("d-none");

        $.ajax({
            type: "POST",
            url: form.attr('action'),
            contentType: "application/json; charset=utf-8",
            dataType: "json",
            data: JSON.stringify(data),
            beforeSend: function(xhr){xhr.setRequestHeader('X-CSRFToken', formData['csrf_token']);},
            success: function (resp_data) {
                console.log("Promoted!");
                if ("result" in resp_data && resp_data["result"] === "success") {
                    flash("info", "Promotion completed!", slidedown=false);
                    $("#spin_promote_map").addClass("d-none");
                    enableActionButtons();
                }

            },
            error: function (resp_data) {
                console.log('Error');
                enableActionButtons();
                $("#spin_promote_map").addClass("d-none");
                flash("danger", resp_data.responseJSON['error'], slidedown=false);

            },
        });
    });


    function fillSpans(elementId, spansContents) {
        let spanElement = $(document.getElementsByName(elementId));
        let parent = spanElement.parent();
        let numberOfChildren = parent.children('span').length + Math.floor(Math.random() * 1000);

        for (let i= 0; i< spansContents.func.length; i++){
            let newSpan = $('<span />');
            let spanId = elementId + "__" + numberOfChildren++;
            newSpan.attr('id', spanId);
            newSpan.addClass("btn edit");
            newSpan.text(buildSpanFunction(spansContents, i));
            parent.append(newSpan);
            $(document).on('click', "#" + spanId.replaceAll(".", "\\\."), edit_);
            update_input_element(parent, elementId.replaceAll(".", "\\\."));
        }
    }


    function applySavedLocalMap() {
        if (!isMetadataSelected()) {
          return;
        };
        resetForm();

        let sourceId = $('input[name*=source_id]')[0].value;
        let localMap = getLocalMap(sourceId, content_type, content_sub_type);
        if (!localMap) {
            console.log("Local map is empty")
            return
        };
        localMap = localMap["map"];
        let currentMap = $activeMap[content_type];
        Object.keys(currentMap).forEach(function (fieldPath) {
            if (localMap[fieldPath]) {
                currentMap[fieldPath] = localMap[fieldPath];
            }
            else {
                currentMap[fieldPath] = {};
            }

            Object.keys(currentMap[fieldPath]).forEach(function (morphStage) {
                let morphValue = currentMap[fieldPath][morphStage]
                if (morphValue) {
                    let elemPath = getElementPath(content_type, morphStage, fieldPath);
                    $(`[name="${elemPath}"]`).val(morphValue);
                    fillSpans(elemPath, currentMap[fieldPath][morphStage]);
                };
            });
        });
    }

    $("#btn_apply_local_map").on("click", function() {
        applySavedLocalMap();
        $("#local_map_status").hide();
    });

    $("#btn_reset_form").on("click", resetForm);

    $("#btn_clear_form").on("click", function (){
        let sourceId = $('input[name*=source_id]')[0].value;
        removeLocalMap(sourceId, content_type, content_sub_type);
        $("#local_map_status").hide();
    });

    // switch to the last opened tab
    let hash = $(location).attr('hash');
    $(`[href="${hash}"]`).click();
});

$(document).keyup(function(e) {
    if (e.key === "Escape")
        $(".modal").modal("hide");
});
